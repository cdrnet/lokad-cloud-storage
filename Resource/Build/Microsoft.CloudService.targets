<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- =========================================================== 
       Setup the place where we look for the Windows Azure SDK 
       =========================================================== -->

  <!-- Set installation properties. These properties can be overriden to support non-default installation -->
  <PropertyGroup>
    <ServiceHostingSDKInstallDir Condition=" '$(ServiceHostingSDKInstallDir)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\ServiceHosting\v1.0@InstallPath)</ServiceHostingSDKInstallDir>
    <ServiceHostingSDKSupport    Condition=" '$(ServiceHostingSDKSupport)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\ServiceHosting\v1.0@ToolsVersionSupportLevel)</ServiceHostingSDKSupport>
    <!-- Ensure ServiceHostingSDKInstallDir has a trailing slash, so it can be concatenated -->
    <ServiceHostingSDKInstallDir Condition=" '$(ServiceHostingSDKInstallDir)' != '' and !HasTrailingSlash('$(ServiceHostingSDKInstallDir)')">$(ServiceHostingSDKInstallDir)\</ServiceHostingSDKInstallDir>

    <ServiceHostingSDKBinDir     Condition=" '$(ServiceHostingSDKBinDir)' == '' ">$(ServiceHostingSDKInstallDir)bin\</ServiceHostingSDKBinDir>

    <ServiceHostingSDKTaskPath   Condition=" '$(ServiceHostingSDKTaskPath)' == '' ">$(ServiceHostingSDKBinDir)Microsoft.ServiceHosting.Tools.MSBuildTasks.dll</ServiceHostingSDKTaskPath>

  </PropertyGroup>

  <!-- IntelliTrace related properties that should be overriden externally to enable IntelliTrace. -->
  <PropertyGroup>
    <EnableIntelliTrace Condition="'$(EnableIntelliTrace)' == ''">false</EnableIntelliTrace>
    <IntelliTraceConnectionString Condition="'$(IntelliTraceConnectionString)' == ''">UseDevelopmentStorage=true</IntelliTraceConnectionString>
  </PropertyGroup>


  <!-- WebDeploy related properties that should be overriden externally to enable WebDeploy. -->
  <PropertyGroup>
    <EnableWebDeploy Condition="'$(EnableWebDeploy)' == ''">false</EnableWebDeploy>
    <WebDeployPorts Condition="'$(WebDeployPorts)' == ''"></WebDeployPorts>
  </PropertyGroup>
  
  <!-- =========================================================== 
       Bring in the CSPack MSBuild task 
       =========================================================== -->
  <UsingTask TaskName="CSPack"                AssemblyFile="$(ServiceHostingSDKTaskPath)" Condition=" Exists('$(ServiceHostingSDKTaskPath)') " />
  <UsingTask TaskName="ValidateServiceFiles"  AssemblyFile="$(ServiceHostingSDKTaskPath)" Condition=" Exists('$(ServiceHostingSDKTaskPath)') " />

  <!-- =========================================================== 
       Bring in our tasks
       =========================================================== -->
  <PropertyGroup>
    <CloudExtensionsDir       Condition=" '$(CloudExtensionsDir)' == '' ">$(MSBuildExtensionsPath)\Microsoft\Cloud Service\1.0\Visual Studio 10.0\</CloudExtensionsDir>

    <CloudExtensionsTaskPath  Condition=" '$(CloudExtensionsTaskPath)' == '' ">$(CloudExtensionsDir)Microsoft.CloudService.MSBuildTasks.dll</CloudExtensionsTaskPath>
  </PropertyGroup>

  <UsingTask TaskName="ItemGroupsOrderedMerge"              AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="IsolatedCSPack"                      AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="FindTargetPath"                      AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="DeleteCurrentDeployment"             AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="WATMessage"                          AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="AddIntelliTraceToServiceDefinition"    AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="AddIntelliTraceToServiceConfiguration" AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="SetProfilerPath"                       AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="AddGeneratedXmlComment"                AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="XPathQuery"                            AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="EnableWebDeploy"  AssemblyFile="$(CloudExtensionsTaskPath)" />

  <!-- ===========================================================  
       Import the Common targets file and override the standard 
       tasks that VS expects to perform a build 
       =========================================================== -->

  <!-- Import the Common targets file -->
  <Import Project="$(MSBuildBinPath)\Microsoft.Common.targets" />

  <!-- =========================================================== 
       Property Declarations
       =========================================================== -->

  <PropertyGroup>

    <!-- The level of ToolsVersionSupportLevel this msi will support-->
    <ServiceHostingVSSupport>7</ServiceHostingVSSupport>
    <!-- Example, bin\Debug\Compute.csx\  -->
    <ServiceOutputDirectory Condition=" '$(ServiceOutputDirectory)' == '' ">$(OutDir)$(ProjectName).csx\</ServiceOutputDirectory>

    <!-- The local path where Windows Azure compiler outputs the roles -->
    <ServiceHosting_HardcodedDirectory Condition =" '$(ServiceHosting_HardcodedDirectory)' == '' ">roles\</ServiceHosting_HardcodedDirectory>

    <!-- The namespace of the service definition and service configuration xml files -->
    <ServiceDefinitionNamespace>http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceDefinition</ServiceDefinitionNamespace>
    <ServiceConfigurationNamespace>http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration</ServiceConfigurationNamespace>
  </PropertyGroup>

  <ItemGroup>
    <ServiceDefinitionCopy Include="@(ServiceDefinition->'%(RecursiveDirectory)%(Filename).build%(Extension)')" />
    <ServiceConfigurationCopy Include="@(ServiceConfiguration->'$(OutDir)%(Filename)%(Extension)')" />
  </ItemGroup>

  <PropertyGroup>

  <!-- Packages the web role into an intermediate folder.
         - When building from inside Visual Studio, we don't want to package the web role. This provides edit/refresh 
           capability on web pages.
         - When building from the command line (or when publishing) we want to package the web role.
    -->
    <PackageWebRole Condition="'$(PackageWebRole)' == '' And '$(BuildingInsideVisualStudio)' == 'True'">False</PackageWebRole>
    <PackageWebRole Condition="'$(PackageWebRole)' == '' And '$(BuildingInsideVisualStudio)' != 'True'">True</PackageWebRole>

  <!-- Warn whether any roles have an instance count of zero at publish.  A package containing a role with an instance count of
       0 will not work when deployed to Windows Azure. To disable check, set WarnOnRolesWithZeroInstance to false in the
       Windows Azure Project -->
    <WarnOnRolesWithZeroInstance Condition="'$(WarnOnRolesWithZeroInstance)' == ''">True</WarnOnRolesWithZeroInstance>
  </PropertyGroup>
  
  <!-- =========================================================== 
       Override the CoreBuildDependsOn property from Microsoft.Common.targets
       to the targets that are needed for the CloudExtensions target
       =========================================================== -->

  <PropertyGroup>
    <CoreBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      PreBuildEvent;
      ResolveReferences;
      PackageComputeService;
      GetTargetPath;
      IncrementalClean;
      PostBuildEvent
    </CoreBuildDependsOn>
  </PropertyGroup>

  <!-- =============== PackageComputeService ======================================== 
       Packages the compute service project
       ============================================================================== -->
  <PropertyGroup>
    <PackageComputeServiceDependsOn>
      BeforePackageComputeService;
      CorePackageComputeService;
      AfterPackageComputeService;
    </PackageComputeServiceDependsOn>
  </PropertyGroup>
  <Target
      Name="PackageComputeService"
      DependsOnTargets="$(PackageComputeServiceDependsOn)" />

  <!-- Redefine this target in your project in order to run tasks just before Build -->
  <Target Name="BeforePackageComputeService" />

  <!-- Redefine this target in your project in order to run tasks just before Build -->
  <Target Name="AfterPackageComputeService" />

  <!-- =============== CorePackageComputeService ==================================== 
       This is the core packaging target. It uses CSPack task to package the compute
       project. 
       ============================================================================== -->
  <PropertyGroup>
    <CorePackageComputeServiceDependsOn>
      VerifySDKInstallation;
      FindServiceDefinition;
      FindServiceConfiguration;
      ResetTargetNames;
      ValidateComputeProject;
      DeleteCurrentDeployment;
      ResolveRoleReferences;
      CopyServiceDefinitionAndConfiguration;
      IntelliTrace;
    </CorePackageComputeServiceDependsOn>
  </PropertyGroup>
  <Target
      Name="CorePackageComputeService"
      DependsOnTargets="$(CorePackageComputeServiceDependsOn)">

    <Message Text="Start - PackageComputeService" />
    <Message Text="ServiceHostingSDKInstallDir is $(ServiceHostingSDKInstallDir)" />
    <Message Text="EnableIntelliTrace is $(EnableIntelliTrace)" />

    <ItemGroup>
      <Roles Include="@(RoleReferences->'%(OutputDir)')" >
        <RoleName>%(RoleName)</RoleName>
        <EntryPoint>%(EntryPoint)</EntryPoint>
        <SourceDir>%(SourceDir)</SourceDir>
      </Roles>
      <RoleProperties Include="@(RoleReferences->'%(RoleName)')">
        <EntryPoint>%(EntryPoint)</EntryPoint>
        <TargetFrameworkVersion>%(RoleTargetFramework)</TargetFrameworkVersion>
        <RolePlugins Condition="'$(EnableIntelliTrace)'=='true' and %(RoleTargetFramework)=='v4.0'">$(IntelliTraceTargetDir)</RolePlugins>
      </RoleProperties>
    </ItemGroup>

    <ItemGroup>
      <SiteMapping Condition="'@(WebRoleReferences)' != ''" 
                   Include="Web:%(RoleName)">
        <PhysicalPath>%(SitePhysicalPath)</PhysicalPath>
      </SiteMapping>
    </ItemGroup>

    <Message Condition="'@(SiteMapping)' != ''" Text="SiteMapping: %(Identity) -> %(PhysicalPath)" />

    <Message Text="ModelFile            is $(ServiceDefinitionFile)" />
    <Message Text="OutputDirectory      is $(ServiceOutputDirectory)" />
    <Message Text="PackRoles            is @(Roles), Name=%(RoleName), EntryPoint=%(EntryPoint), SourceDir=%(SourceDir)" />
    <Message Text="RoleProperties       is @(RoleProperties), EntryPoint=%(EntryPoint), TargetFrameworkVersion=%(TargetFrameworkVersion)" />
    <Message Text="ServiceDefinitionCopy is @(ServiceDefinitionCopy)" />
    <Message Text="ServiceConfigurationCopy is @(ServiceConfigurationCopy)" />

    <Message Text="Calling ServicePack" />

    <CSPack
      ServiceDefinitionFile="@(ServiceDefinitionCopy)"
      Output="$(ServiceOutputDirectory)"
      PackRoles="@(Roles)"
      SiteMapping="@(SiteMapping)"
      RoleProperties="@(RoleProperties)"
      CopyOnly="true"
     >
      <Output TaskParameter="OutputFiles" ItemName="FileWrites" />
    </CSPack>

    <!-- Add generated policy files and others to the FileWrites list -->
    <ItemGroup>
      <FileWrites Include=" $(ServiceOutputDirectory)**\__entrypoint.txt " />
    </ItemGroup>

    <Message Text="DiagnosticsFilesCreated is @(DiagnosticsFilesCreated)" />
    <Delete Files="@(DiagnosticsFilesCreated)" ContinueOnError="true"/>
    
    <Message Text="End - PackageComputeService" />

  </Target>


  <!-- =============== VerifySDKInstallation ======================================== 
       Verify that the Computing SDK is installed and it is compatible with this version of tools
       ============================================================================== -->
  <Target
      Name="VerifySDKInstallation">

    <WATMessage Condition=" !Exists('$(ServiceHostingSDKInstallDir)') or 
                            !Exists('$(ServiceHostingSDKBinDir)') or 
                            !Exists('$(ServiceHostingSDKTaskPath)') "
                Type="Error"
                Code="WAT080" />

    <WATMessage Condition="'$(ServiceHostingSDKSupport)' != '$(ServiceHostingVSSupport)'" Type="Error" Code="WAT050" HelpKeyword="SDKVersionNotSupported" />

  </Target>

  <!-- =============== FindServiceDefinition  ============================================ 
       Finds the service definition in the project and raises an error if it is not found. 
       ============================================================================== -->
  <Target
      Name="FindServiceDefinition">

    <!--Find the Compute Application Model File -->
    <Message Text="ServiceDefinition in @(ServiceDefinition)" Importance="normal"/>

    <WATMessage Condition=" '@(ServiceDefinition)' == '' "
           Type="Error"
           Code="WAT010"
           HelpKeyword="MissingModelFile"/>

    <!-- Only one active service definition can be active, check for that and throw an error -->
    <WATMessage Condition=" '@(ServiceDefinition)' == '' or '@(ServiceDefinition->'%(dummy)')' != '' "
           Type="Error"
           Code="WAT020"
           HelpKeyword="OneActiveModelFile" />

  </Target>

  <!-- =============== FindServiceConfiguration  ============================================ 
       Finds the Service Configuration file in the project and raises an error if it is not found. 
       ============================================================================== -->
  <Target
      Name="FindServiceConfiguration">

    <Message Text="ServiceConfigurationFile is @(ServiceConfiguration)" />

    <!-- Compute project must contain at least one service configuration file -->
    <WATMessage Condition=" '@(ServiceConfiguration)' == '' "
                Type="Error"
                Code="WAT030"
                HelpKeyword="MissingServiceConfiguration" />

    <!-- Only one service configuration per compute project, check for that and throw an error -->
    <WATMessage Condition=" '@(ServiceConfiguration)' == '' or '@(ServiceConfiguration->'%(dummy)')' != '' "
           Type="Error"
           Code="WAT040"
           HelpKeyword="OneServiceConfigurationFile" />

  </Target>


  <!-- =============== ResetTargetNames  ==================================== 
       Resets the $(TargetName) and $(TargetExt) to be compute specific.

       Properties:
           TargetName - the name of the compute app model file 
           TargetExt  - the extension of the compute app model file 
       ========================================================================== -->
  <Target
      Name="ResetTargetNames">

    <PropertyGroup>
      <TargetDir>$(ServiceOutputDirectory)</TargetDir>
      <TargetName>@(ServiceDefinition->'%(filename)')</TargetName>
      <TargetExt>.rd</TargetExt>
      <TargetFileName>$(TargetName)$(TargetExt)</TargetFileName>
      <TargetPath>$(TargetDir)$(TargetFileName)</TargetPath>
    </PropertyGroup>

    <Message Text="Reset the targetDir      to $(TargetDir)" />
    <Message Text="Reset the TargetName     to $(TargetName)" />
    <Message Text="Reset the TargetExt      to $(TargetExt)" />
    <Message Text="Reset the TargetFileName to $(TargetFileName)" />
    <Message Text="Reset the TargetPath     to $(TargetPath)" />

  </Target>

  <!-- =============== DeleteCurrentDeployment ================================== 
       Delete the current running deployment that is attached with the project.

       ========================================================================== -->

  <Target
      Name="DeleteCurrentDeployment">

    <!-- This task runs only under Visual Studio -->
    <DeleteCurrentDeployment Condition="'$(BuildingInsideVisualStudio)' == 'true' " />

  </Target>

  <!-- =============== ResolveRoleReferences ======================== 
       Finds the role projects defined in the project file.      

       [OUT]
       
       RoleReferences: (item) list of all project references for
            web and worker. Each item contains these properties:
              - @         : Path to the project file.
              - RoleType  : The type of the role: Web, or Worker.
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - SourceDir : (web specific) The source location of the web role.
              - EntryPoint: The entry point assembly file name for web/worker role.
              
      ========================================================================== -->
  <PropertyGroup>
    <ResolveRoleReferencesDependsOn>
      VerifyRoleReferences;
      ResolveWebRoleReferences;
      ResolveWorkerRoleReferences;
    </ResolveRoleReferencesDependsOn>
  </PropertyGroup>
  <Target
      Name="ResolveRoleReferences"
      DependsOnTargets="$(ResolveRoleReferencesDependsOn)">

    <!-- Combine WebRoleReferences and WorkerRoleReferences -->
    <ItemGroup>
      <RoleReferences Include="@(WebRoleReferences); @(WorkerRoleReferences)" />
    </ItemGroup>

    <Message Text="Role = @(RoleReferences), role=%(RoleType), projname=%(ProjectName), output=%(OutputDir)" />

  </Target>


  <!-- =============== VerifyRoleReferences ======================== 
       Verifies that the key output exists for all role references 

      ========================================================================== -->
  <Target
      Name="VerifyRoleReferences" Condition=" '@(_ResolvedProjectReferencePaths)' != '' ">
    
    <WATMessage
      Condition=" !Exists('%(_ResolvedProjectReferencePaths.Identity)')"
      Type="Error"
      Arguments="%(_ResolvedProjectReferencePaths.Identity)"
      Code="WAT070"
      />
  </Target>

  <!-- =============== ResolveWebRoleReferences ======================== 
       Resolves the web role references

       [OUT]
       
       WebRoleReferences: (item) list of all project references for web
              - @         : Path to the project file.
              - RoleType  : The type of the role: Web
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - SourceDir : The source location of the web role
              - EntryPoint: The entry point assembly file name for web.
              - SitePhysicalPath: The physical path for the main site
              
      ========================================================================== -->
  <Target
      Name="ResolveWebRoleReferences">

    <!-- Get all the roles from the project references section -->
    <ItemGroup>
      <WebRoleProjects Include="@(ProjectReferenceWithConfiguration->'%(Identity)')" Condition=" '%(RoleType)' == 'Web' " >
        <ProjectName>%(Name)</ProjectName>
        <Configuration>%(ProjectReferenceWithConfiguration.Configuration)</Configuration>
        <Platform>%(ProjectReferenceWithConfiguration.Platform)</Platform>
      </WebRoleProjects>
    </ItemGroup>

    <MSBuild
      Condition=" '@(WebRoleProjects)' != '' "
      Projects="$(MSBuildProjectFullPath)"
      Targets="ResolveSingleWebRoleReference"
      Properties="WebRoleProject=%(Identity);WebRoleProjectName=%(Name);WebRoleConfiguration=%(Configuration);WebRolePlatform=%(Platform);PackageWebRole=$(PackageWebRole)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="WebRoleReferences" />
    </MSBuild>

    <Message Text="WebRoleReferences=@(WebRoleReferences) %(RoleType), %(RoleName), %(ProjectName), %(Configuration), %(Platform), %(SourceDir), %(OutputDir), %(EntryPoint), %(SitePhysicalPath)" />

    <!-- Register intermediate published web role for Clean -->
    <ItemGroup Condition=" '@(WebRoleReferences)' != '' ">
      <FileWrites Include="%(WebRoleReferences.OutputDir)**\*.*" />
    </ItemGroup>

  </Target>

  <!-- =============== ResolveSingleWebRoleReference ======================== 
       Resolves a single web role reference. This target publishes the web
       role into an intermediate folder making it ready for CSPack.
       
       [IN]
       
       PackageWebRole: (property) a flag to indecate if we need to package the web role       
       WebRoleProject: (property) the propject of web role
       WebRoleProjectName: (property) the project name of the web role
       WebRoleConfiguration: (property) the configuration of the web role
       WebRolePlatform: (property) the platform of the web role

       [OUT]
       
       WebRoleReference: (item) Contains information about the web role
              - @         : Path to the project file, same as $(WebRoleProject)
              - RoleType  : The type of the role: Web
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role, same as $(WebRoleProjectName)
              - Configuration: The configuration used on the role project.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - EntryPoint: The entry point assembly file name for the role.
              - SourceDir : The source location of the web role
              - SitePhysicalPath: The physical path for the main site
              
      ========================================================================== -->
  <Target
      Name="ResolveSingleWebRoleReference"
      Condition=" '$(WebRoleProject)' != '' and '$(WebRoleProjectName)' != '' "
      Returns="@(WebRoleReference)">

    <Message Text="PackageWebRole=$(PackageWebRole)" />
    <Message Text="WebRoleProject=$(WebRoleProject)" />
    <Message Text="WebRoleProjectName=$(WebRoleProjectName)" />
    <Message Text="WebRoleConfiguration=$(WebRoleConfiguration)" />
    <Message Text="WebRolePlatform=$(WebRolePlatform)" />

    <ItemGroup>
      <Namespaces Include="$(ServiceDefinitionNamespace)">
        <Prefix>csd</Prefix>
      </Namespaces>
    </ItemGroup>

    <!-- Find if the web role has a site -->
    <XPathQuery
        Condition=" '@(ServiceDefinition)' != '' "
        Namespaces="@(Namespaces)"
        XPath="csd:ServiceDefinition/csd:WebRole[@name='$(WebRoleProjectName)']/csd:Sites/csd:Site/@name"
        XmlFile="@(ServiceDefinition)"
        >

      <Output TaskParameter="QueryResult" ItemName="Sites" />
    </XPathQuery>
    
    <Message Condition=" '@(Sites)' == '' and '$(PackageWebRole)' == 'false' " Text="Turning on packagewebrole because no sites found." />
    <PropertyGroup>
      <PackageWebRole Condition=" '@(Sites)' == '' and '$(PackageWebRole)' == 'false' ">True</PackageWebRole>
    </PropertyGroup>
   
    <PropertyGroup>
      <!-- If the role configuration wasn't passed, use the current cloud service project configuration -->
      <WebRoleConfiguration Condition="'$(WebRoleConfiguration)' == ''">$(Configuration)</WebRoleConfiguration>
      <!-- If the role platform wasn't passed, use the current cloud service project platform -->
      <WebRolePlatform Condition="'$(WebRolePlatform)' == ''">$(Platform)</WebRolePlatform>
    </PropertyGroup>

    <ItemGroup>
      <WebRoleReference Include="$(WebRoleProject)" >
        <RoleType>Web</RoleType>
        <RoleName>$(WebRoleProjectName)</RoleName>
        <ProjectName>$(WebRoleProjectName)</ProjectName>
        <Configuration>$(WebRoleConfiguration)</Configuration>
        <Platform>$(WebRolePlatform)</Platform>
      </WebRoleReference>
    </ItemGroup>

    <Message Text="WebRoleReference=@(WebRoleReference) %(RoleType), %(RoleName), %(ProjectName), %(Configuration), %(Platform)" />

    <!-- ===============================
         Get the target path for the role 
         =============================== -->
    <MSBuild
      Projects="@(WebRoleReference)"
      Targets="GetTargetPath"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="WebTargetPathItem" />
    </MSBuild>

    <PropertyGroup>
      <!-- Stores the assembly file name (no path) of the web role -->
      <WebEntryPoint Condition="'@(WebTargetPathItem)'!=''">%(Filename)%(Extension)</WebEntryPoint>
      <!-- The full target dir of the web role binary folder -->
      <WebTargetDir Condition="'@(WebTargetPathItem)'!=''">%(RootDir)%(Directory)</WebTargetDir>
      <!-- The fullpath to the source directory. This is derived from where the project is located -->
      <WebSourceDir Condition="'@(WebRoleReference)'!=''">%(RootDir)%(Directory)</WebSourceDir>
      <!-- To exclude or not to exclude the pdb files. By default they are not excluded. Set this to true to exclude them -->
      <WebExcludeGeneratedDebugSymbol Condition="'$(ExcludeWebRoleGeneratedDebugSymbol)' == ''">False</WebExcludeGeneratedDebugSymbol>
    </PropertyGroup>

    <Message Text="WebEntryPoint=$(WebEntryPoint)" />
    <Message Text="WebTargetDir=$(WebTargetDir)" />
    <Message Text="WebSourceDir=$(WebSourceDir)" />
    <Message Text="WebExcludeGeneratedDebugSymbol=$(WebExcludeGeneratedDebugSymbol)" />

    <!-- ===============================
         Collect the TargetFrameworkVersion 
         property from web project 
         =============================== -->
    <MSBuild
      Projects="@(WebRoleReference)"
      Targets="GetTargetFrameworkVersion"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" PropertyName="RoleTargetFramework" />
    </MSBuild>

    <Message Text="WebTargetFramework = $(RoleTargetFramework)" />

    <!-- ===============================
         Collect the web files from web project 
         =============================== -->
    <MSBuild
      Condition=" '$(PackageWebRole)' == 'True' "
      Projects="@(WebRoleReference)"
      Targets="PipelineTransformPhase"
      Properties="Configuration=%(Configuration); Platform=%(Platform); ExcludeGeneratedDebugSymbol=$(WebExcludeGeneratedDebugSymbol); PipelineDependsOnBuild=False"
      ContinueOnError="false">
      <Output TaskParameter="TargetOutputs" ItemName="TransformedWebFiles" />
    </MSBuild>

    <Message Condition=" '$(PackageWebRole)' == 'True' " 
             Text="TransformedWebFiles = @(TransformedWebFiles), DestinationRelativePath=%(DestinationRelativePath), Exclude=%(Exclude), FromTarget=%(FromTarget), Category=%(Category), ProjectFileType=%(ProjectFileType)" />

    <ItemGroup Condition=" '$(PackageWebRole)' == 'True' ">
      <WebFiles Condition="'@(TransformedWebFiles)' != '' and '%(Exclude)' == 'False'"
                      Include="$([System.IO.Path]::Combine(`$(WebSourceDir)`, '%(Identity)'))">
        <TargetPath>%(DestinationRelativePath)</TargetPath>
      </WebFiles>
    </ItemGroup>

    <!-- ===============================
         Get all the CopyToOutput items from the role 
         =============================== -->
    <MSBuild
      Condition=" '$(PackageWebRole)' == 'True' "
      Projects="@(WebRoleReference)"
      Targets="GetCopyToOutputDirectoryItems"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="CopyToOutputItems" />
    </MSBuild>

    <Message Condition=" '$(PackageWebRole)' == 'True' "
             Text="CopyToOutputItems=%(CopyToOutputItems.Identity) -> %(TargetPath)" />

    <ItemGroup Condition=" '$(PackageWebRole)' == 'True' ">
      <WebFiles Include="$(WebTargetDir)%(TargetPath)" Condition=" '@(CopyToOutputItems)' != '' ">
        <TargetPath>bin\%(TargetPath)</TargetPath>
      </WebFiles>
    </ItemGroup>

    <!-- ===============================
         Get all files in the bin folder
         =============================== -->

    <ItemGroup Condition=" '$(PackageWebRole)' == 'False'">
      <FilesInBin Include="$(WebTargetDir)**\*" />
      <WebFiles Include="@(FilesInBin)">
        <TargetPath>bin\%(FilesInBin.RecursiveDir)%(FilesInBin.Filename)%(FilesInBin.Extension)</TargetPath>
      </WebFiles>
    </ItemGroup>
    
    <!-- ===============================
         At this point the WebFiles list is ready, just publish it
         =============================== -->

    <Message Text="WebFiles=%(WebFiles.Identity) -> %(TargetPath)" />

    <ItemGroup>
      <IntermediateWebOutputPathItem Include="$(IntermediateOutputPath)%(WebRoleReference.ProjectName)\" />
    </ItemGroup>

    <Message Text="IntermediateWebOutputPathItem=@(IntermediateWebOutputPathItem)" ></Message>
    
    <PropertyGroup>
       <IntermediateWebOutputPath>@(IntermediateWebOutputPathItem->'%(Fullpath)')</IntermediateWebOutputPath>
    </PropertyGroup>
    
    <!-- Setup the intermediate path and site pysical path in the case of packaging of webrole -->
    <PropertyGroup Condition=" '$(PackageWebRole)' == 'True' ">
      <SitePhysicalPath>$(IntermediateWebOutputPath)</SitePhysicalPath>
    </PropertyGroup>
    
    <!-- Setup the intermediate path and site pysical path in the case of no packaging of webrole -->
    <PropertyGroup Condition=" '$(PackageWebRole)' != 'True' ">
      <SitePhysicalPath>$(WebSourceDir)</SitePhysicalPath>
    </PropertyGroup>

    <!-- Make sure the intermediate web ouput folder is created -->
    <MakeDir Directories="$(IntermediateWebOutputPath)" />

    <!-- Remove the files located under the intermediate output folder that are orphaned.
         In other words, remove those files that are not part of the web project anymore.
         For example, the user renamed a file from test1.dll to test2.dll.
    -->
    <ItemGroup>
      <OrphanedWebFiles Include="$(IntermediateWebOutputPath)**\*.*" Exclude="@(WebFiles->'$(IntermediateWebOutputPath)%(TargetPath)')" />
    </ItemGroup>
    <Delete Files="@(OrphanedWebFiles)" ContinueOnError="true" />

    <!-- Publish the web to the intermediate folder -->
    <Copy
      Condition=" '@(WebFiles)' != '' "
      SourceFiles="@(WebFiles)"
      DestinationFiles="@(WebFiles->'$(IntermediateWebOutputPath)%(TargetPath)')"
      SkipUnchangedFiles="true" />

    <!-- Add OutputDir, EntryPoint and SourceDir metadata to the WebRoleReference item group -->
    <ItemGroup>
      <WebRoleReference Condition="'@(WebRoleReference)' != ''">
        <OutputDir>$(IntermediateWebOutputPath)</OutputDir>
        <EntryPoint>$(WebEntryPoint)</EntryPoint>
        <SourceDir>$(WebSourceDir)</SourceDir>
        <RoleTargetFramework>$(RoleTargetFramework)</RoleTargetFramework>
        <SitePhysicalPath>$(SitePhysicalPath)</SitePhysicalPath>
      </WebRoleReference>
    </ItemGroup>

    <Message Text="WebRoleReference=@(WebRoleReference) %(RoleType), %(RoleName), %(ProjectName), %(Configuration), %(Platform), %(SourceDir), %(OutputDir), %(EntryPoint)" />

  </Target>

  <!-- =============== ResolveWorkerRoleReferences ======================== 
       Resolves the worker role references

       [OUT]
       WorkerRoleReferences: (item) list of all project references for worker
              - @         : Path to the project file.
              - RoleType  : The type of the role: Worker
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - SourceDir : not used
              - SitePhysicalPath: not used
              
      ========================================================================== -->
  <Target
      Name="ResolveWorkerRoleReferences">

    <!-- Get all the roles from the project references section -->
    <ItemGroup>
      <WorkerRoleProjects Include="@(ProjectReferenceWithConfiguration->'%(Identity)')" Condition=" '%(RoleType)' == 'Worker' " >
        <ProjectName>%(Name)</ProjectName>
        <Configuration>%(ProjectReferenceWithConfiguration.Configuration)</Configuration>
        <Platform>%(ProjectReferenceWithConfiguration.Platform)</Platform>
      </WorkerRoleProjects>
    </ItemGroup>

    <MSBuild
      Condition=" '@(WorkerRoleProjects)' != '' "
      Projects="$(MSBuildProjectFullPath)"
      Targets="ResolveSingleWorkerRoleReference"
      Properties="WorkerRoleProject=%(Identity);WorkerRoleProjectName=%(Name);WorkerRoleConfiguration=%(Configuration);WorkerRolePlatform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="WorkerRoleReferences" />
    </MSBuild>

    <Message Text="WorkerRoleReferences=@(WorkerRoleReferences) %(RoleType), %(RoleName), %(ProjectName), %(Configuration), %(Platform), %(OutputDir), %(EntryPoint)" />

    <!-- Register intermediate published worker role for Clean -->
    <ItemGroup Condition=" '@(WorkerRoleReferences)' != '' ">
      <FileWrites Include="%(WorkerRoleReferences.OutputDir)**\*.*" />
    </ItemGroup>

  </Target>

  <!-- =============== ResolveSingleWorkerRoleReference ======================== 
       Resolves a single worker role reference. This target publishes the worker
       role into an intermediate folder making it ready for CSPack.
       
       [IN]
       
       WorkerRoleProject: (property) the propject of worker role
       WorkerRoleProjectName: (property) the project name of the worker role
       WorkerRoleConfiguration: (property) the configuration of the worker role
       WorkerRolePlatform: (property) the platform of the worker role

       [OUT]
       
       WorkerRoleReference: (item) Contains information about the worker role
              - @         : Path to the project file, same as $(WorkerRoleProject)
              - RoleType  : The type of the role: Worker
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role, same as $(WorkerRoleProjectName)
              - Configuration: The configuration used on the role project.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - EntryPoint: The entry point assembly file name for the role.
              - SourceDir : not used
              - SitePhysicalPath: not used
              
      ========================================================================== -->
  <Target
      Name="ResolveSingleWorkerRoleReference"
      Condition=" '$(WorkerRoleProject)' != '' and '$(WorkerRoleProjectName)' != '' "
      Returns="@(WorkerRoleReference)">

    <Message Text="WorkerRoleProject=$(WorkerRoleProject)" />
    <Message Text="WorkerRoleProjectName=$(WorkerRoleProjectName)" />
    <Message Text="WorkerRoleConfiguration=$(WorkerRoleConfiguration)" />
    <Message Text="WorkerRolePlatform=$(WorkerRolePlatform)" />

    <PropertyGroup>
      <!-- If the role configuration wasn't passed, use the current cloud service project configuration -->
      <WorkerRoleConfiguration Condition="'$(WorkerRoleConfiguration)' == ''">$(Configuration)</WorkerRoleConfiguration>
      <!-- If the role platform wasn't passed, use the current cloud service project platform -->
      <WorkerRolePlatform Condition="'$(WorkerRolePlatform)' == ''">$(Platform)</WorkerRolePlatform>
    </PropertyGroup>

    <ItemGroup>
      <WorkerRoleReference Include="$(WorkerRoleProject)">
        <RoleType>Worker</RoleType>
        <RoleName>$(WorkerRoleProjectName)</RoleName>
        <ProjectName>$(WorkerRoleProjectName)</ProjectName>
        <Configuration>$(WorkerRoleConfiguration)</Configuration>
        <Platform>$(WorkerRolePlatform)</Platform>
        <!-- worker doesn't use SourceDir, set it to empty as default -->
        <SourceDir></SourceDir>
        <SitePhysicalPath></SitePhysicalPath>
      </WorkerRoleReference>
    </ItemGroup>

    <!-- Setup the intermediate path where we want to publish the worker role -->
    <ItemGroup>
      <IntermediateWorkerOutputPathItem Include="$(IntermediateOutputPath)%(WorkerRoleReference.ProjectName)\" />
    </ItemGroup>
    <PropertyGroup>
      <IntermediateWorkerOutputPath>@(IntermediateWorkerOutputPathItem->'%(Fullpath)')</IntermediateWorkerOutputPath>
    </PropertyGroup>

    <!-- ===============================
         Get the target path for the role 
         =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="GetTargetPath"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="WorkerTargetPathItem" />
    </MSBuild>

    <PropertyGroup>
      <!-- Stores the worker target directory -->
      <WorkerTargetDir Condition="'@(WorkerTargetPathItem)'!=''">%(RootDir)%(Directory)</WorkerTargetDir>
      <!-- Stores the assembly file name (no path) of the worker role -->
      <WorkerEntryPoint Condition="'@(WorkerTargetPathItem)'!=''">%(Filename)%(Extension)</WorkerEntryPoint>
    </PropertyGroup>

    <Message Text="WorkerTargetDir = $(WorkerTargetDir)" />
    <Message Text="WorkerEntryPoint = $(WorkerEntryPoint)" />

    <!--  =============================== 
          Get all the output groups for the role 
           =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="
        BuiltProjectOutputGroup;
        DebugSymbolsProjectOutputGroup;
        DocumentationProjectOutputGroup;
        SatelliteDllsProjectOutputGroup;
        SGenFilesOutputGroup"
      Properties="AddAppConfigToBuildOutputs=true; Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="OutputGroups" />
    </MSBuild>

    <Message Text="Output=%(OutputGroups.Identity) -> %(TargetPath)" />

    <ItemGroup>
      <WorkerFiles Include="@(OutputGroups)" Condition=" '@(OutputGroups)' != '' " >
        <TargetPath>%(TargetPath)</TargetPath>
      </WorkerFiles>
    </ItemGroup>

    <!-- ===============================
         Get all the dependency output groups for the role 
         =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="
        BuiltProjectOutputGroupDependencies;
        DebugSymbolsProjectOutputGroupDependencies;
        DocumentationProjectOutputGroupDependencies;
        SGenFilesOutputGroupDependencies"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="OutputGroupsDependencies" />
    </MSBuild>

    <Message Text="OutputDependencies=%(OutputGroupsDependencies.Identity)" />

    <!-- Figure out the dependencies that need to be copied by checking if the dependency exists
         in the worker target directory. -->
    <ItemGroup>
      <CopyLocalDependencies Include="@(OutputGroupsDependencies)" Condition="Exists('$(WorkerTargetDir)%(Filename)%(Extension)')" />
    </ItemGroup>
    <Message Text="CopyLocalDependencies=%(CopyLocalDependencies.Identity)" />
    <ItemGroup>
      <WorkerFiles Include="@(CopyLocalDependencies)" Condition=" '@(CopyLocalDependencies)' != '' " >
        <TargetPath>%(Filename)%(Extension)</TargetPath>
      </WorkerFiles>
    </ItemGroup>

    <!--  ===============================
          Get all Satellite dependecies 
          =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="
        SatelliteDllsProjectOutputGroupDependencies"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="SatelliteOutputGroupsDependencies" />
    </MSBuild>

    <FindTargetPath
      Files="@(SatelliteOutputGroupsDependencies)"
      FindUnderTargetDir="$(WorkerTargetDir)"
      >
      <Output TaskParameter="ItemWithTargetPath" ItemName="SatelliteOutputGroupsDependenciesWithTargetPath" />
    </FindTargetPath>

    <Message Text="SatelliteOutputGroupsDependenciesWithTargetPath=@(SatelliteOutputGroupsDependenciesWithTargetPath), %(TargetPath)" />

    <ItemGroup>
      <WorkerFiles Include="@(SatelliteOutputGroupsDependenciesWithTargetPath)" Condition=" '@(SatelliteOutputGroupsDependenciesWithTargetPath)' != '' ">
        <TargetPath>%(TargetPath)</TargetPath>
      </WorkerFiles>
    </ItemGroup>

    <!-- ===============================
         Get TargetFrameworkVersion for the role project
         =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="GetTargetFrameworkVersion"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" PropertyName="RoleTargetFramework" />
    </MSBuild>
    <Message Text="WorkerTargetFramework = $(RoleTargetFramework)" />

    <!-- ===============================
         Get all the CopyToOutput items from the role 
         =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="
        GetCopyToOutputDirectoryItems"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="CopyToOutputItems" />
    </MSBuild>

    <Message Text="CopyToOutputItems=%(CopyToOutputItems.Identity) -> %(TargetPath)" />

    <ItemGroup>
      <WorkerFiles Include="$(WorkerTargetDir)%(TargetPath)" Condition=" '@(CopyToOutputItems)' != '' ">
        <TargetPath>%(TargetPath)</TargetPath>
      </WorkerFiles>
    </ItemGroup>

    <Message Text="WorkerFiles=%(WorkerFiles.Identity) -> %(TargetPath)" />

    <!-- ===============================
         At this point the WorkerFiles list is ready, just publish the Worker
         =============================== -->

    <!-- Make sure the intermediate worker ouput folder is created -->
    <MakeDir Directories="$(IntermediateWorkerOutputPath)" />

    <!-- Remove the files located under the intermediate output folder that are orphaned.
         In other words, remove those files that are not part of the worker project anymore.
         For example, the user renamed a file from test1.dll to test2.dll.
    -->
    <ItemGroup>
      <OrphanedWorkerFiles Include="$(IntermediateWorkerOutputPath)**\*.*" Exclude="@(WorkerFiles->'$(IntermediateWorkerOutputPath)%(TargetPath)')" />
    </ItemGroup>
    <Delete Files="@(OrphanedWorkerFiles)" ContinueOnError="true" />

    <!-- Publish the worker to the intermediate folder -->
    <Copy
      Condition=" '@(WorkerFiles)' != '' "
      SourceFiles="@(WorkerFiles)"
      DestinationFiles="@(WorkerFiles->'$(IntermediateWorkerOutputPath)%(TargetPath)')"
      SkipUnchangedFiles="true" />

    <!-- Add OutputDir and EntryPoint metadata to the WorkerRoleReference item group -->
    <ItemGroup>
      <WorkerRoleReference>
        <OutputDir>$(IntermediateWorkerOutputPath)</OutputDir>
        <EntryPoint>$(WorkerEntryPoint)</EntryPoint>
        <RoleTargetFramework>$(RoleTargetFramework)</RoleTargetFramework>
      </WorkerRoleReference>
    </ItemGroup>

    <Message Text="WorkerRoleReference=@(WorkerRoleReference) %(RoleType), %(RoleName), %(ProjectName), %(Platform), %(OutputDir), %(EntryPoint)" />

  </Target>

  <!-- =============== ValidateComputeProject ===================================== 
       Runs validations on the compute project to verify it's valid
       ============================================================================ -->
  <PropertyGroup>
    <ValidateComputeProjectDependsOn>
      GetVMRoleCounts;
      ValidateRoleProjects;
      ValidateServiceFiles;
    </ValidateComputeProjectDependsOn>
  </PropertyGroup>
  <Target
      Name="ValidateComputeProject"
      DependsOnTargets="$(ValidateComputeProjectDependsOn)">
  </Target>

  <!-- =============== ValidateRoleProjects ======================================= 
       Validates that we have the right number of role projects to match the 
       declared application architecture. Generates errors if these are not correct
       ============================================================================ -->
  <Target
      Name="ValidateRoleProjects" DependsOnTargets="GetVMRoleCounts">

    <CreateItem Include="@(ProjectReference)" Condition=" '%(RoleType)' == 'Web' " >
      <Output TaskParameter="Include" ItemName="WebRoles" />
    </CreateItem>

    <CreateItem Include="@(ProjectReference)" Condition=" '%(RoleType)' == 'Worker' " >
      <Output TaskParameter="Include" ItemName="WorkerRoles" />
    </CreateItem>

    <Message Text="Web Project        is @(WebRoles)" />
    <Message Text="Worker Project     is @(WorkerRoles)" />
    <Message Text="VM Project         is @(VMRoles)" />

    <!-- Error out if unknown architecture or we don't have enough role projects for the architecture type -->
    <WATMessage Condition=" '@(WebRoles)'=='' And '@(WorkerRoles)'=='' And '@(VMRoles)'=='' " Type="Error" Code="WAT001" HelpKeyword="MissingWebOrWorkerRole"/>

  </Target>


  <!-- =============== ValidateServiceFiles ========================================= 
       Validates the integrity of both the definition file and the configuration files.       
       ============================================================================== -->
  <Target
      Name="ValidateServiceFiles">

    <ValidateServiceFiles
        ServiceDefinitionFile="@(ServiceDefinition)"
        ServiceConfigurationFile="@(ServiceConfiguration)">
    </ValidateServiceFiles>

  </Target>


  <!-- =============== CreateManifestResourceNames ================================ 
       The IDE is calling into this target. We don't have any resource files. 
       So, implement this target to do nothing
       ============================================================================ -->

  <Target Name="CreateManifestResourceNames" />

  <!-- =============== PrepareForPackaging ========================================
       Sets up some properties needed for packaging
       ============================================================================ -->

  <Target Name="PrepareForPackaging">

    <!-- Make sure we package the web role -->
    <PropertyGroup>
      <PackageWebRole>True</PackageWebRole>
    </PropertyGroup>
    
  </Target>
  
  <!-- =============== CorePublish ================================================
       Builds the project(s) but in single-file-package mode (i.e., does not specify
       the /copyonly parameter to cspack) and copies the generated output to the 
       publish folder.
       ============================================================================ -->

  <!-- Overriding the PublishDependsOn list from common targets. -->
  <PropertyGroup>
    <PublishDependsOn>
      BeforePublish;
      CorePublish;
      AfterPublish
    </PublishDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <CorePublishDependsOn>
      PrepareForPackaging;
      Build;
      CheckRoleInstanceCount;
      CopyServiceDefinitionAndConfiguration;
      ConfigureWebDeploy;
      IntelliTrace;
    </CorePublishDependsOn>
  </PropertyGroup>
  
  <Target 
      Name="CorePublish"
      DependsOnTargets="$(CorePublishDependsOn)">

    <Message Text="CorePublish: PackageWebRole = $(PackageWebRole)" />

    <Message Text="Publishing starting..." />

    <Message Text="RolePlugins       is @(RoleProperties->'%(RolePlugins)')" />

    <Message Text="Publishing to '$(OutDir)Publish'" />

    <MakeDir Directories=" $(OutDir)Publish " />

    <Message Text="ServiceDefinitionCopy is @(ServiceDefinitionCopy)" />

    <Message Text="ServiceConfigurationCopy is @(ServiceConfigurationCopy)" />

    <Message Text="Roles is @(Roles)" />

    <CSPack
      ServiceDefinitionFile="@(ServiceDefinitionCopy)"
      Output="$(OutDir)Publish\$(ProjectName).cspkg"
      PackRoles="@(Roles)"
      SiteMapping="@(SiteMapping)"
      RoleProperties="@(RoleProperties)"
      CopyOnly="false"
      >
    </CSPack>

    <!-- Copy service configuration to output directory -->
    <Message Text="Copying the service configuration file." />

    <Copy SourceFiles="@(ServiceConfigurationCopy)" DestinationFolder="$(OutDir)Publish" />

    <Message Text="DiagnosticsFilesCreated is @(DiagnosticsFilesCreated)" />
    <Delete Files="@(DiagnosticsFilesCreated)" ContinueOnError="true" />

    <Message Text="Publishing process has completed."/>

  </Target>

  <!-- =========================================================== 
       Override CoreCleanDependsOn property from Microsoft.Common.targets
       to allow us to Delete the current deployment
       =========================================================== -->

  <PropertyGroup>
    <CoreCleanDependsOn>
      DeleteCurrentDeployment;
      $(CoreCleanDependsOn)
    </CoreCleanDependsOn>
  </PropertyGroup>

  <!-- =============== IntelliTrace ================================================= 
       IntelliTrace properties & target
       ============================================================================== -->

  <PropertyGroup>
    <KB983301Installed Condition=" '$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Updates\Microsoft Visual Studio 2010 IntelliTrace Collection (x64)\KB983301@ThisVersionInstalled)' != '' ">true</KB983301Installed>
    <VisualStudioProductPath Condition=" '$(VisualStudioProductPath)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\10.0\Setup\VS@ProductDir)</VisualStudioProductPath>
    <VisualStudioIDEPath Condition=" '$(VisualStudioIDEPath)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\10.0@InstallDir)</VisualStudioIDEPath>
    <VSDataCollectorsPath Condition=" '$(VSDataCollectorsPath)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\10.0\TraceDebugger@VSTraceCollector)</VSDataCollectorsPath>
    <VSReferencedAssembliesPath Condition=" '$(VSReferencedAssembliesPath)' == '' ">$(VisualStudioIDEPath)ReferenceAssemblies\v2.0\</VSReferencedAssembliesPath>
    <VSPrivateAssembliesPath Condition=" '$(VSPrivateAssembliesPath)' == '' ">$(VisualStudioIDEPath)PrivateAssemblies\</VSPrivateAssembliesPath>
    <VSPublicAssembliesPath Condition=" '$(VSPublicAssembliesPath)' == '' ">$(VisualStudioIDEPath)PublicAssemblies\</VSPublicAssembliesPath>
    <CloudToolsInstallPath Condition=" '$(CloudToolsInstallPath)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Azure Tools for Microsoft Visual Studio 2010\1.0@InstallPath)</CloudToolsInstallPath>

    <!-- In order to enable testing without tools installed, fallback to default path if InstallPath is not set in the Registry. 
         The files are copied there by CctPackage project build. $(ProgramFiles) is set to Program Files (x86) by MSBuild. -->
    <DefaultCloudToolsPath Condition=" '$(DefaultCloudToolsPath)' == '' ">$(ProgramFiles)\Windows Azure Tools\1.3\Visual Studio 10.0\</DefaultCloudToolsPath>
    <CloudToolsInstallPath Condition=" '$(CloudToolsInstallPath)' == '' ">$(DefaultCloudToolsPath)</CloudToolsInstallPath>
    <CloudToolsIntelliTracePath Condition=" '$(CloudToolsIntelliTracePath)' == '' ">$(CloudToolsInstallPath)IntelliTrace\</CloudToolsIntelliTracePath>

    <IntelliTraceTargetDir>$(BaseIntermediateOutputPath)\$(Configuration)\IntelliTrace</IntelliTraceTargetDir>
    <IntelliTraceRuntimeDir>$(IntelliTraceTargetDir)\Runtime</IntelliTraceRuntimeDir>
    <IntelliTraceLoggerDir>$(IntelliTraceRuntimeDir)\64</IntelliTraceLoggerDir>
    <IntelliTraceAddonManifestPath>$(CloudToolsIntelliTracePath)\IntelliTrace.csplugin</IntelliTraceAddonManifestPath>
    <UserIntelliTraceCollectionPlanPath>$(AppData)\Microsoft\VisualStudio\10.0\Cloud Tools\collectionplan.xml</UserIntelliTraceCollectionPlanPath>
    <DefaultIntelliTraceCollectionPlanPath>$(CloudToolsIntelliTracePath)\collectionplan.xml</DefaultIntelliTraceCollectionPlanPath>
    <IntelliTraceCollectionPlanPath Condition="Exists('$(UserIntelliTraceCollectionPlanPath)')">$(UserIntelliTraceCollectionPlanPath)</IntelliTraceCollectionPlanPath>
    <IntelliTraceCollectionPlanPath Condition=" '$(IntelliTraceCollectionPlanPath)' == '' ">$(DefaultIntelliTraceCollectionPlanPath)</IntelliTraceCollectionPlanPath>
  </PropertyGroup>

  <ItemGroup>
    <IntelliTraceFiles
      Include= "$(CloudToolsIntelliTracePath)\Microsoft.Cct.IntelliTrace.Common.dll;
                $(CloudToolsIntelliTracePath)\Microsoft.Cct.IntelliTrace.Agent.dll;
                $(CloudToolsIntelliTracePath)\IntelliTraceAgentHost.exe;
                $(CloudToolsIntelliTracePath)\IntelliTraceAgentHost.exe.config;
                $(CloudToolsIntelliTracePath)\IntelliTraceStartupTask.exe;
                $(CloudToolsIntelliTracePath)\IntelliTraceStartupTask.exe.config;
                $(IntelliTraceAddonManifestPath);
                $(ServiceHostingSDKInstallDir)\ref\Microsoft.WindowsAzure.StorageClient.dll;
                "/>

    <IntelliTraceRuntimeFiles
      Include= "$(VSDataCollectorsPath)\IntelliTrace.exe;
                $(VSDataCollectorsPath)\IntelliTrace.exe.config;
                $(VSDataCollectorsPath)\Microsoft.VisualStudio.DefaultDataQueries.dll;
                $(VSDataCollectorsPath)\Microsoft.VisualStudio.VIL.NotifyPointInProcHost.dll;
                $(VSPublicAssembliesPath)\Microsoft.VisualStudio.IntelliTrace.dll;
                $(VSPrivateAssembliesPath)\Microsoft.VisualStudio.VIL.Host.dll;
                $(SYSTEMROOT)\assembly\GAC_MSIL\Microsoft.VisualStudio.VIL\10.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualStudio.VIL.dll;
                "/>

    <VSTraceProfiler64Path
      Condition=" '@(VSTraceProfiler64Path)' == '' and ('$(PROCESSOR_ARCHITECTURE)' == 'AMD64' or $(PROCESSOR_ARCHITEW6432) == 'AMD64' ) "
      Include="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{301EC75B-AD5A-459C-A4C4-911C878FA196}\InprocServer32', '', '', RegistryView.Registry64))" />

    <!-- On 32 bit machines the TraceLogProfiler is installed to different location and has different file name. It is not being registered. -->
    <VSTraceProfiler64Path
      Condition=" '@(VSTraceProfiler64Path)' == '' "
      Include="$(VisualStudioProductPath)Team Tools\TraceDebugger Tools\TraceLogProfiler.dll" />

    <VSTraceProfiler32Path
      Condition=" '@(VSTraceProfiler32Path)' == '' "
      Include="$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{301EC75B-AD5A-459C-A4C4-911C878FA196}\InprocServer32@)" />

  </ItemGroup>

  <!-- Prepares files needed for IntelliTrace Support -->
  <Target Name="IntelliTrace" Condition="'$(EnableIntelliTrace)'=='true'" DependsOnTargets="CopyServiceDefinitionAndConfiguration">

    <Message Text="EnableIntelliTrace is $(EnableIntelliTrace)" />
    <Message Text="KB983301Installed is $(KB983301Installed)" />
    <Message Text="IntelliTraceFiles is @(IntelliTraceFiles)" />
    <Message Text="IntelliTraceRuntimeFiles is @(IntelliTraceRuntimeFiles)" />
    <Message Text="IntelliTraceTargetDir is $(IntelliTraceTargetDir)" />
    <Message Text="IntelliTraceRuntimeDir is $(IntelliTraceRuntimeDir)" />
    <Message Text="IntelliTraceCollectionPlanPath is $(IntelliTraceCollectionPlanPath)" />
    <Message Text="VSTraceProfiler64Path is @(VSTraceProfiler64Path)" />
    <Message Text="VSTraceProfiler32Path is @(VSTraceProfiler32Path)" />
    <Message Text="PROCESSOR_ARCHITECTURE is $(PROCESSOR_ARCHITECTURE)" />
    <Message Text="PROCESSOR_ARCHITEW6432 is $(PROCESSOR_ARCHITEW6432)" />

    <WATMessage Condition="'@(VSTraceProfiler64Path)' == '' or !Exists('@(VSTraceProfiler64Path)')" Type="Error" Code="WAT090" />

    <Message Text="Adding IntelliTrace components..." />

    <MakeDir Directories="$(IntelliTraceTargetDir);$(IntelliTraceRuntimeDir)" />

    <!-- Copy the Cloud Tools IntelliTrace support files (agent, startup task, etc) -->
    <Copy
      SourceFiles="@(IntelliTraceFiles)"
      DestinationFolder="$(IntelliTraceTargetDir)"
      SkipUnchangedFiles="true"
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Copy the IntelliTrace runtime files -->
    <Copy
      SourceFiles="@(IntelliTraceRuntimeFiles)"
      DestinationFolder="$(IntelliTraceRuntimeDir)"
      SkipUnchangedFiles="true"
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- 
      ===============================================================
          BEGIN (When KB983301 is installed)
      ===============================================================
    -->

    <!-- Copy the 32 bit TraceLogProfiler.dll. -->
    <Copy
      Condition=" '$(KB983301Installed)' == 'true' "
      SourceFiles="@(VSTraceProfiler32Path)"
      DestinationFolder="$(IntelliTraceRuntimeDir)"
      SkipUnchangedFiles="true"
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Copy the 64 bit TraceLogProfiler.dll. -->
    <Copy
      Condition=" '$(KB983301Installed)' == 'true' "
      SourceFiles="@(VSTraceProfiler64Path)"
      DestinationFiles="$(IntelliTraceRuntimeDir)\TraceLogProfiler64.dll"
      SkipUnchangedFiles="true"
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- 
      ===============================================================
          BEGIN (When KB983301 is NOT installed)
      ===============================================================
    -->

    <MakeDir
      Condition=" '$(KB983301Installed)' != 'true' "
      Directories="$(IntelliTraceLoggerDir)" />

    <!-- Copy the IntelliTrace runtime files to the logger directory. Workaround to enable xcopy deployable IntelliTrace if KB983301 is not installed. (see explanation below)  -->
    <Copy
      Condition=" '$(KB983301Installed)' != 'true' "
      SourceFiles="@(IntelliTraceRuntimeFiles)"
      DestinationFolder="$(IntelliTraceLoggerDir)"
      SkipUnchangedFiles="true"
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Copy the 32 bit TraceLogProfiler.dll.
      The logger (IntelliTrace.exe) is a 32bit process, and it requires 32bit TraceLogProfiler in the same directory. 
      Azure host processes, however, 64 bit and use 64 bit version of TraceLogProfiler. Therefore, we need a separate directory for the logger. -->
    <Copy
      Condition=" '$(KB983301Installed)' != 'true' "
      SourceFiles="@(VSTraceProfiler32Path)"
      DestinationFolder="$(IntelliTraceLoggerDir)"
      SkipUnchangedFiles="true"
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Copy the 64 bit TraceLogProfiler.dll and rename it to 64TraceLogProfiler.dll. 
      This is a workaround to enable xcopy-deployable IntelliTrace. 
      At runtime the TraceLogProfiler discovers the path to the logger using COR_PROFILER_PATH environment variable, and assumes it ends with "TraceLogProfiler.dll".
      It treats everything before "TraceLogProfiler.dll" as a directory name.Therefore when the profiler executable is named "64TraceLogProfiler.dll", 
      the calculated logger path would be "64" (This needs to match IntelliTraceLoggerDir property).
    -->
    <Copy
      Condition=" '$(KB983301Installed)' != 'true' "
      SourceFiles="@(VSTraceProfiler64Path)"
      DestinationFiles="$(IntelliTraceRuntimeDir)\64TraceLogProfiler.dll"
      SkipUnchangedFiles="true"
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <SetProfilerPath
      Condition=" '$(KB983301Installed)' != 'true' "
      PluginManifestFile="$(IntelliTraceTargetDir)\IntelliTrace.csplugin"
      ProfilerPath="%RdRoleRoot%\plugins\IntelliTrace\Runtime\64TraceLogProfiler.dll"
      />

    <!-- 
      ===============================================================
          END (When KB983301 is NOT installed)
      ===============================================================
    -->

    <!-- Copy the IntelliTrace collection plan file.  -->
    <Copy
      SourceFiles="$(IntelliTraceCollectionPlanPath)"
      DestinationFolder="$(IntelliTraceRuntimeDir)"
      SkipUnchangedFiles="true"
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Add IntelliTrace related settings to .csdef file  
    <AddIntelliTraceToServiceDefinition
      ServiceDefinitionFile="@(ServiceDefinitionCopy)" /> -->

    <ItemGroup>
      <RolesToConfigure Include="@(RoleReferences->'%(RoleName)')" Condition="'%(RoleReferences.RoleTargetFramework)' == 'v4.0'" />
    </ItemGroup>

    <Message Text="IntelliTrace roles = @(RolesToConfigure)" />
    
    <!-- Add IntelliTrace related settings to .cscfg file  -->
    <AddIntelliTraceToServiceConfiguration
      ServiceConfigurationFile="@(ServiceConfigurationCopy)"
      IntelliTraceConnectionString="$(IntelliTraceConnectionString)"
      Roles="@(RolesToConfigure)"/>

  </Target>
  <!-- End IntelliTrace Support -->

  <!-- Enables WebDeploy on web roles if the user chooses to do so -->
  <Target Name="ConfigureWebDeploy" Condition="'$(EnableWebDeploy)'=='true'" DependsOnTargets="CopyServiceDefinitionAndConfiguration">

    <ItemGroup>
      <RolesToConfigure Include="@(WebRoleReferences->'%(RoleName)')" />
    </ItemGroup>
    
    <Message Text="Adding WebDeploy component..." />
    <Message Text="EnableWebDeploy is $(EnableWebDeploy)" />
    <Message Text="WebDeployPorts = $(WebDeployPorts)" />
    <Message Text="WebDeploy roles = @(RolesToConfigure)" />
    <Message Text="ServiceDefinitionCopy is @(ServiceDefinitionCopy)" />

    <!-- Add WebDeploy Plugin -->
    <EnableWebDeploy
      ServiceConfigurationFile="@(ServiceConfigurationCopy)"
      ServiceDefinitionFile="@(ServiceDefinitionCopy)"
      RolesAndPorts="$(WebDeployPorts)" />
  </Target>
  <!-- End WebDeploy Support -->

  <Target Name="CopyServiceDefinitionAndConfiguration">

    <Message Text="Running CopyServiceDefinitionAndConfiguration target" />

    <!-- Create a copy of service configuration -->
    <Message Text="Copying the service configuration." />
    <Copy
      SourceFiles="@(ServiceConfiguration)"
      DestinationFiles="@(ServiceConfigurationCopy)" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Add the "file generated, do not edit" style comment to the new copy. -->
    <AddGeneratedXmlComment
      GeneratedFile="@(ServiceConfigurationCopy)"
      SourceFile="@(ServiceConfiguration)" />

    <!-- Create a copy of service definition -->
    <Message Text="Copying the service definition." />
    <Copy
      SourceFiles="@(ServiceDefinition)"
      DestinationFiles="@(ServiceDefinitionCopy)" />

    <!-- Add the "file generated, do not edit" style comment to the new copy. -->
    <AddGeneratedXmlComment
      GeneratedFile="@(ServiceDefinitionCopy)"
      SourceFile="@(ServiceDefinition)" />
    
  </Target>  

  <Target Name="CheckRoleInstanceCount" Condition=" '$(WarnOnRolesWithZeroInstance)' == 'True' ">

    <ItemGroup>
      <Namespaces Include="$(ServiceConfigurationNamespace)">
        <Prefix>csc</Prefix>
      </Namespaces>
    </ItemGroup>


    <!-- Find roles where the instance count is 0 -->
    <XPathQuery
        Condition=" '@(ServiceConfiguration)' != '' "
        Namespaces="@(Namespaces)"
        XPath="csc:ServiceConfiguration/csc:Role/csc:Instances[@count='0']/../@name"
        XmlFile="@(ServiceConfiguration)"
        >

      <Output TaskParameter="QueryResult" ItemName="RolesWithZeroInstanceCount" />
    </XPathQuery>

    <Message Condition=" '@(RolesWithZeroInstanceCount)'!='' " Text="RolesWithZeroInstanceCount = @(RolesWithZeroInstanceCount)" />

    <WATMessage Condition=" '@(RolesWithZeroInstanceCount)'!='' " Type="Error" Code="WAT100" Arguments="@(RolesWithZeroInstanceCount,',')" />

  </Target>
  
  <Target Name="GetVMRoleCounts">

    <ItemGroup>
      <Namespaces Include="$(ServiceDefinitionNamespace)">
        <Prefix>csd</Prefix>
      </Namespaces>
    </ItemGroup>


    <!-- Find all Virtual Machine roles -->
    <XPathQuery
        Condition=" '@(ServiceDefinition)' != '' "
        Namespaces="@(Namespaces)"
        XPath="csd:ServiceDefinition/csd:VirtualMachineRole/@name"
        XmlFile="@(ServiceDefinition)"
        >

      <Output TaskParameter="QueryResult" ItemName="VMRoles" />
    </XPathQuery>
  
  </Target>
  
</Project>
